# 애플리케이션 소스 코드에서 도커 이미지까지
- 빌드 중에 실행한 명령과 파일시스템 변경은 이미지 레이어에 그대로 저장
- Dockerfile 스크립트는 매우 유연한 패키징 도구
- 압축파일 압축해제, 윈도 인스톨러 실행 등 다양한 일을 패키징에 포함 가능
---

#### 빌드 툴체인을 한번에 패키징해서 공유
- 개발에 필요한 모든 도구를 배포하는 Dockerfile 스크립트로 이미지 빌드
- 애플리케이션 패키징을 위한 Dockerfile 에서 도구배포 이미지를 사용해 소스코드 컴파일



*인스트럭션*
```
FROM DIAMOL/BASE AS BUILD-STAGE
run ECHO 'Building...' > build.txt

FROM diamol/base as test-stage
COPY --from=build-stage /build.txt /build.txt
RUN echo 'Testing...'  >

FROM diamol/base
COPY --from=test-stage /build.txt /build.txt
CMD cat /build.txt
```
- 각 빌드단계는 독립적으로 실행.
- 앞 단계에서 만들어진 디렉터리나 파일 복사 가능 (**FROM** 인스트럭션 활용)
- **RUN** 빌드중에 컨테이너 안에서 명령을 실행한 다음 그 결과를 이미지 레이어에 저장
    - FROM 인스트럭션에서 지정한 이미지에서 실행 가능한 명령어여야 함
- 각 빌드 단계는 서로 격리되어 있음

---
### 예제
#### 1. java source code
- 자바 애플리케이션은 컴파일을 거쳐야 함
- 빌드단계에서 소스코드 복사한 다음 패키징으로 jar 생성
- 이 파일만 최종 애플리케이션 이미지에 복사
```
--기반 이미지
FROM diamol/maven AS builder  

-- 이미지에 작업디렉터리 만들고 pom.xml 파일 복사
WORKDIR /usr/src/iotd  
COPY pom.xml .
-- 메이븐을 실행해 필요한 의존모듈 다운
-- 시간이 걸리기 때문에 별도의 단계로 분리해 레이어 캐시활용
RUN mvn -B dependency:go-offline  

-- 나머지 소스코드 복사
COPY . .
-- 패키지 실행 (애플리케이션을 빌드하고 패키징)
RUN mvn package

# app
-- 기반이미지
FROM diamol/openjdk 

-- 작업 디렉터리 생성 후 의존모듈과 컴파일된 애플리케이션을 포함하는 단일파일 복사
WORKDIR /app
COPY --from=builder /usr/src/iotd/target/iotd-service-0.1.0.jar .


-- 80번 포트 외부로 공개
EXPOSE 80
-- cmd 같은 인스트럭션. 해당 이미지가 컨테이너로 실행되면 도커가 이 인스트럭션에 정의된 명령을 실행
ENTRYPOINT ["java", "-jar", "/app/iotd-service-0.1.0.jar"]

```
---
#### 컨테이너 간 통신
```
컨테이너간 통신에 사용되는 도커 네트워크 생성
docker network create nat

컨테이너를 실행할때 --network 옵션을 사용해서 네트워크 직접 지정
docker container run --name example -d -p 800:80 --network nat image-of-the-day

- 포트 80을 호스트 컴퓨터 800번 포트로 포워딩
- 네트워크 nat 지정
- image-of-the-day 이미지를 컨테이너로 실행 (컨테이너 이름 example)

```

#### 2. node.js
- node.js 애플리케이션은 자바스크립트 (인터프리터형 언어)
- 컴파일 절차 필요 없음
- node.js 런타임과 소스코드가 애플리케이션 이미지에 필요
- CMD 는 이미지 빌드 다 된후에 run 에서 실행되는거라 제일아래 의존모듈 복사한 다음에 실행됨.
```
-- 빌더 이미지
FROM diamol/node AS builder 

-- 작업 디렉토리 지정
WORKDIR /src
-- 의존 모듈이 정의된 파일 복사
COPY src/package.json .
-- 의존 모듈 다운
RUN npm install

# app
-- 베이스 이미지
FROM diamol/node

--포트 열고 노드 서버 실행
EXPOSE 80
CMD ["node", "server.js"]

-- 작업디랙토리 설정, 의존 모듈 복사. 
WORKDIR /app
COPY --from=builder /src/node_modules/ /app/node_modules/
COPY src/ .

```



#### 3. Go
- 네이티브 바이너리로 컴파일되는 현대적인 크로스 플랫폼 언어
- 별도의 런타임이 필요하지 않음

```
# go 언어 도구가 설치된 기반 이미지
FROM diamol/golang AS builder

# 일반적으로 main.go 단일파일로 구성 
# 일반적으로 의존 모듈을 내려받는 단계 없이 곧장 빌드에 들어감
COPY main.go .
RUN go build -o /server

# app
FROM diamol/base
# 환경변수 설정
ENV IMAGE_API_URL="http://iotd/image" \
    ACCESS_API_URL="http://accesslog/access-log"

# 애플리케이션 실행
CMD ["/web/server"]


WORKDIR /web
# HTML 파일 복사
COPY index.html .
# 웹서버 바이너리 복사
COPY --from=builder /server .
RUN chmod +x server

```

## 멀티 스테이지 장점
- 표준화
    - 운영체제, 도구 와 상관없이 빌드과정이 도커 컨테이너 내부에서 이뤄짐

    - 정확한 버전으로 갖추고 있음

- 성능 향상
    - 멀티 스테이지 빌드의 각 단계는 자신만의 캐시를 따로 갖는다
    - 도커는 빌드중 각 인스트럭션에 해당하는 레이어 캐시를 찾음
    - 레이어 캐시를 못찾으면 남은 인스트럭션 실행 (해당 단계 안에서만) 

    - 다음 단계는 다시 캐시를 재사용하면서 시작 가능

- 최종 산출물 이미지를 작게 유지 가능
    - 컴파일러 등 그 도구가 사용되는 단계만으로 도구의 포함 여부를 국한시킬 수 있음
    - 최종 이미지에서 불필요한 도구를 뺄수 있음
    - 애플리케이션 시작시간 단축
    - 의존모듈 자체를 줄여 취약점을 이용한 외부 공격 가능성 차단